<!doctype html>
<html lang="en"> 
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script
      id="p5scripttag"
      src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"
      integrity="sha512-uaz5GpnQoE6t5echKlX8P52czvsIGgLPcvlzfvRubLZ1Hp8JemUDnbUiAahbVtPb+jUVrNETuXvAhDDF/N3M4w=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>

    <script>
      const bgCol = "#F2F0E7";
const accentCol = "#fd4578";

hljs.initHighlightingOnLoad();

const updateTargetDims = () => {
  // width is max-width of `.contentContainer` - its padding
  // return [min(windowWidth, 900 - 80), 700]
  return [windowWidth * (1 / 2), windowHeight];
};

const setCodeAndPlan = (code, plan) => {
  const codeElm = document.getElementById("code");
  if (codeElm) {
    // codeElm.innerText = code;
    codeElm.innerHTML = hljs.highlight(code, { language: "python" }).value;
  }

  const planElm = document.getElementById("plan");
  if (planElm) {
    // planElm.innerText = plan.trim();
    planElm.innerHTML = hljs.highlight(plan, { language: "plaintext" }).value;
  }
};

windowResized = () => {
  resizeCanvas(...updateTargetDims());
  awaitingPostResizeOps = true;
};

const animEase = (t) => 1 - (1 - Math.min(t, 1.0)) ** 5;

// ---- global constants ----

const globalAnimSpeed = 1.1;
const scaleFactor = 0.57;

// ---- global vars ----

let globalTime = 0;
let manualSelection = false;

let currentElemInd = 0;

let treeStructData = {"edges": [], "layout": [[0.0, 0.0], [0.3333333333333333, 0.0], [0.6666666666666666, 0.0], [1.0, 0.0]], "plan": ["To address the task of predicting water potability, I will use a Gradient\nBoosting Classifier from the scikit-learn library, which is a powerful and\nflexible ensemble learning method. I will handle missing values in the dataset\nby imputing them with the median of each feature. The model's performance will\nbe evaluated using Root Mean Squared Logarithmic Error (RMSLE), F1-score, and\naccuracy on a hold-out validation set. I will split the data into training and\nvalidation sets, train the Gradient Boosting model, and then compute and print\nthe evaluation metrics.", "To tackle the task of predicting water potability based on various chemical\nmeasurements, I will use the Support Vector Machine (SVM) classifier with a\nradial basis function (RBF) kernel from the scikit-learn library. Given the\npresence of missing values in the dataset, I will impute these using the median\nvalue for each feature. The dataset will be split into a training set and a\nvalidation set. The model's performance will be evaluated using Root Mean\nSquared Logarithmic Error (RMSLE), F1-score, and accuracy metrics, which are\nsuitable for classification tasks with imbalanced datasets. The final step will\ninvolve printing these evaluation metrics to assess the model's effectiveness.", "To address the task of predicting water potability, I will employ a Support\nVector Machine (SVM) classifier with a radial basis function (RBF) kernel, which\nis effective for binary classification problems. The dataset will be\npreprocessed to handle missing values by imputing them using the median of the\nrespective columns. The model's performance will be evaluated using Root Mean\nSquared Logarithmic Error (RMSLE), F1-score, and accuracy. These metrics will be\ncalculated on a hold-out validation set after splitting the data into training\nand validation sets. This approach will provide a baseline performance for the\nSVM model on the water potability prediction task.", "To address the task of predicting water potability, I will employ a Support\nVector Machine (SVM) classifier, which is effective for binary classification\ntasks. The dataset will be preprocessed to handle missing values by imputing\nthem with the median of each respective column. For feature scaling, I will\nstandardize the dataset using StandardScaler to improve the performance of the\nSVM. The dataset will be split into training and validation sets to evaluate the\nmodel's performance. The evaluation metrics used will be Root Mean Squared\nLogarithmic Error (RMSLE), F1-score, and accuracy."], "code": ["import pandas as pd\nfrom sklearn.experimental import enable_iterative_imputer\nfrom sklearn.impute import IterativeImputer\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_squared_log_error, f1_score, accuracy_score\nimport numpy as np\n\n# Load the data\ndata = pd.read_csv(\"./input/water_potability.csv\")\n\n# Impute missing values\nimputer = IterativeImputer(random_state=0)\ndata_imputed = imputer.fit_transform(data)\ndata_imputed = pd.DataFrame(data_imputed, columns=data.columns)\n\n# Split data into features and target\nX = data_imputed.drop(\"Potability\", axis=1)\ny = data_imputed[\"Potability\"]\n\n# Split data into training and validation sets\nX_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# Initialize and train the Gradient Boosting Classifier\nmodel = GradientBoostingClassifier(random_state=42)\nmodel.fit(X_train, y_train)\n\n# Predict on validation set\ny_pred = model.predict(X_val)\ny_pred_proba = model.predict_proba(X_val)[:, 1]\n\n# Calculate RMSLE, F1-score, and accuracy\nrmsle = np.sqrt(mean_squared_log_error(y_val, y_pred_proba))\nf1 = f1_score(y_val, y_pred)\naccuracy = accuracy_score(y_val, y_pred)\n\n# Print the evaluation metrics\nprint(f\"RMSLE: {rmsle}\")\nprint(f\"F1-score: {f1}\")\nprint(f\"Accuracy: {accuracy}\")\n", "import pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.svm import SVC\nfrom sklearn.metrics import mean_squared_log_error, f1_score, accuracy_score\nfrom sklearn.pipeline import make_pipeline\nimport numpy as np\n\n# Load the data\ndata = pd.read_csv(\"./input/water_potability.csv\")\n\n# Separate features and target\nX = data.drop(columns=\"Potability\")\ny = data[\"Potability\"]\n\n# Split data into training and validation sets\nX_train, X_val, y_train, y_val = train_test_test_split(\n    X, y, test_size=0.2, random_state=42\n)\n\n# Create a pipeline for imputing, scaling and classifying using SVM\npipeline = make_pipeline(\n    SimpleImputer(strategy=\"median\"),\n    StandardScaler(),\n    SVC(kernel=\"rbf\", probability=True),\n)\n\n# Fit the model\npipeline.fit(X_train, y_train)\n\n# Predict probabilities and classes\nprobabilities = pipeline.predict_proba(X_val)[:, 1]\npredictions = pipeline.predict(X_val)\n\n# Calculate RMSLE, F1-score and accuracy\nrmsle = np.sqrt(mean_squared_log_error(y_val, probabilities))\nf1 = f1_score(y_val, predictions)\naccuracy = accuracy_score(y_val, predictions)\n\n# Print the evaluation metrics\nprint(f\"RMSLE: {rmsle}\")\nprint(f\"F1-score: {f1}\")\nprint(f\"Accuracy: {accuracy}\")\n", "import pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.svm import SVC\nfrom sklearn.metrics import mean_squared_log_error, f1_score, accuracy_score\nfrom sklearn.pipeline import make_pipeline\n\n# Load the dataset\ndata = pd.read_csv(\"./input/water_potability.csv\")\n\n# Separate features and target\nX = data.drop(\"Potability\", axis=1)\ny = data[\"Potability\"]\n\n# Handle missing values\nimputer = SimpleImputer(strategy=\"median\")\nX_imputed = imputer.fit_transform(X)\n\n# Split data into train and validation sets\nX_train, X_val, y_train, y_val = train_test_test_split(\n    X_imputed, y, test_size=0.2, random_state=42\n)\n\n# Standardize features\nscaler = StandardScaler()\nX_train_scaled = scaler.fit_transform(X_train)\nX_val_scaled = scaler.transform(X_val)\n\n# Initialize and train the SVM classifier\nsvm_model = SVC(kernel=\"rbf\", probability=True)\nsvm_model.fit(X_train_scaled, y_train)\n\n# Predict on the validation set\ny_val_pred = svm_model.predict(X_val_scaled)\ny_val_proba = svm_model.predict_proba(X_val_scaled)[:, 1]\n\n# Evaluate the model\nrmsle = np.sqrt(mean_squared_log_error(y_val, y_val_proba))\nf1 = f1_score(y_val, y_val_pred)\naccuracy = accuracy_score(y_val, y_val_pred)\n\n# Print the evaluation metrics\nprint(f\"RMSLE: {rmsle}\")\nprint(f\"F1-score: {f1}\")\nprint(f\"Accuracy: {accuracy}\")\n", "import pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.svm import SVC\nfrom sklearn.metrics import mean_squared_log_error, f1_score, accuracy_score\nfrom math import sqrt\n\n# Load the dataset\ndata = pd.read_csv(\"./input/water_potability.csv\")\n\n# Impute missing values\nimputer = SimpleImputer(strategy=\"median\")\ndata_imputed = imputer.fit_transform(data)\ndata = pd.DataFrame(data_imputed, columns=data.columns)\n\n# Separate features and target\nX = data.drop(\"Potability\", axis=1)\ny = data[\"Potability\"]\n\n# Split the data into train and validation sets\nX_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# Feature scaling\nscaler = StandardScaler()\nX_train_scaled = scaler.fit_transform(X_train)\nX_val_scaled = scaler.transform(X_val)\n\n# Initialize and train the SVM classifier\nsvm_model = SVC(probability=True)\nsvm_model.fit(X_train_scaled, y_train)\n\n# Predict on the validation set\ny_pred = svm_model.predict(X_val_scaled)\ny_pred_proba = svm_model.predict_proba(X_val_scaled)[:, 1]\n\n# Calculate the evaluation metrics\nrmsle = sqrt(mean_squared_log_error(y_val, y_pred_proba))\nf1 = f1_score(y_val, y_pred)\naccuracy = accuracy_score(y_val, y_pred)\n\n# Print the evaluation metrics\nprint(f\"RMSLE: {rmsle}\")\nprint(f\"F1-score: {f1}\")\nprint(f\"Accuracy: {accuracy}\")\n"], "term_out": ["RMSLE: 0.3306586700432098\nF1-score: 0.33714285714285713\nAccuracy: 0.6463414634146342\nExecution time: 2 seconds seconds (time limit is an hour).", "Traceback (most recent call last):\n  File \"runfile.py\", line 18, in <module>\n    X_train, X_val, y_train, y_val = train_test_test_split(\nNameError: name 'train_test_test_split' is not defined. Did you mean: 'train_test_split'?\nExecution time: a second seconds (time limit is an hour).", "Traceback (most recent call last):\n  File \"runfile.py\", line 22, in <module>\n    X_train, X_val, y_train, y_val = train_test_test_split(\nNameError: name 'train_test_test_split' is not defined. Did you mean: 'train_test_split'?\nExecution time: a moment seconds (time limit is an hour).", "RMSLE: 0.32185354849676745\nF1-score: 0.43454038997214484\nAccuracy: 0.6905487804878049\nExecution time: 3 seconds seconds (time limit is an hour)."], "analysis": ["The Gradient Boosting Classifier model has been successfully trained and evaluated on the validation dataset. The RMSLE is 0.3307, indicating a moderate log error in probability predictions. The F1-score is relatively low at 0.3371, suggesting that the model's precision and recall balance for the positive class is not optimal. The accuracy of the model is 64.63%, which is moderate but indicates potential for improvement.", "The error in the code is due to a typo in the function name `train_test_test_split`, which should be corrected to `train_test_split`. This typo prevents the code from executing further and evaluating the model on the dataset.", "The code has a typo in the function name for splitting the dataset. The function should be `train_test_split` instead of `train_test_test_split`. Correcting this typo should allow the code to proceed without the `NameError`.", "The SVM classifier achieved an RMSLE of 0.3219, an F1-score of 0.4345, and an accuracy of 0.6905 on the validation set. These results indicate that the model has moderate accuracy but might be struggling with the balance between precision and recall, as suggested by the lower F1-score."], "exp_name": "2-delicate-iguana-of-cookies", "metrics": [0, 0, 0, 0]}

let lastClick = 0;
let firstFrameTime = undefined;

let nodes = [];
let edges = [];

let lastScrollPos = 0;

setup = () => {
  canvas = createCanvas(...updateTargetDims());
};

class Node {
  x;
  y;
  size;
  xT;
  yT;
  xB;
  yB;
  treeInd;
  color;
  relSize;
  animationStart = Number.MAX_VALUE;
  animationProgress = 0;
  isStatic = false;
  hasChildren = false;
  isRootNode = true;
  isStarred = false;
  selected = false;
  renderSize = 10;
  edges = [];
  bgCol;

  constructor(x, y, relSize, treeInd) {
    const minSize = 35;
    const maxSize = 60;

    const maxColor = 10;
    const minColor = 125;

    this.relSize = relSize;
    this.treeInd = treeInd;
    this.size = minSize + (maxSize - minSize) * relSize;
    this.color = minColor + (maxColor - minColor) * relSize;
    this.bgCol = Math.round(Math.max(this.color / 2, 0));

    this.x = x;
    this.y = y;
    this.xT = x;
    this.yT = y - this.size / 2;
    this.xB = x;
    this.yB = y + this.size / 2;

    nodes.push(this);
  }

  startAnimation = (offset = 0) => {
    if (this.animationStart == Number.MAX_VALUE)
      this.animationStart = globalTime + offset;
  };

  child = (node) => {
    let edge = new Edge(this, node);
    this.edges.push(edge);
    edges.push(edge);
    this.hasChildren = true;
    node.isRootNode = false;
    return node;
  };

  render = () => {
    if (globalTime - this.animationStart < 0) return;

    const mouseXlocalCoords = (mouseX - width / 2) / scaleFactor;
    const mouseYlocalCoords = (mouseY - height / 2) / scaleFactor;
    const isMouseOver =
      dist(mouseXlocalCoords, mouseYlocalCoords, this.x, this.y) <
      this.renderSize / 1.5;
    if (isMouseOver) cursor(HAND);
    if (isMouseOver && mouseIsPressed) {
      nodes.forEach((n) => (n.selected = false));
      this.selected = true;
      setCodeAndPlan(
        treeStructData.code[this.treeInd],
        treeStructData.plan[this.treeInd],
      );
      manualSelection = true;
    }

    this.renderSize = this.size;
    if (!this.isStatic) {
      this.animationProgress = animEase(
        (globalTime - this.animationStart) / 1000,
      );
      if (this.animationProgress >= 1) {
        this.isStatic = true;
      } else {
        this.renderSize =
          this.size *
          (0.8 +
            0.2 *
              (-3.33 * this.animationProgress ** 2 +
                4.33 * this.animationProgress));
      }
    }

    fill(this.color);
    if (this.selected) {
      fill(accentCol);
    }

    noStroke();
    square(
      this.x - this.renderSize / 2,
      this.y - this.renderSize / 2,
      this.renderSize,
      10,
    );

    noStroke();
    textAlign(CENTER, CENTER);
    textSize(this.renderSize / 2);
    fill(255);
    // fill(lerpColor(color(accentCol), color(255), this.animationProgress))
    text("{ }", this.x, this.y - 1);
    // DEBUG PRINT:
    // text(round(this.relSize, 2), this.x, this.y - 1)
    // text(this.treeInd, this.x, this.y + 15)

    const dotAnimThreshold = 0.85;
    if (this.isStarred && this.animationProgress >= dotAnimThreshold) {
      let dotAnimProgress =
        (this.animationProgress - dotAnimThreshold) / (1 - dotAnimThreshold);
      textSize(
        ((-3.33 * dotAnimProgress ** 2 + 4.33 * dotAnimProgress) *
          this.renderSize) /
          2,
      );
      if (this.selected) {
        fill(0);
        stroke(0);
      } else {
        fill(accentCol);
        stroke(accentCol);
      }
      strokeWeight((-(dotAnimProgress ** 2) + dotAnimProgress) * 2);
      text("*", this.x + 20, this.y - 11);
      noStroke();
    }

    if (!this.isStatic) {
      fill(bgCol);
      const progressAnimBaseSize = this.renderSize + 5;
      rect(
        this.x - progressAnimBaseSize / 2,
        this.y -
          progressAnimBaseSize / 2 +
          progressAnimBaseSize * this.animationProgress,
        progressAnimBaseSize,
        progressAnimBaseSize * (1 - this.animationProgress),
      );
    }
    if (this.animationProgress >= 0.9) {
      this.edges
        .sort((a, b) => a.color() - b.color())
        .forEach((e, i) => {
          e.startAnimation((i / this.edges.length) ** 2 * 1000);
        });
    }
  };
}

class Edge {
  nodeT;
  nodeB;
  animX = 0;
  animY = 0;
  animationStart = Number.MAX_VALUE;
  animationProgress = 0;
  isStatic = false;
  weight = 0;

  constructor(nodeT, nodeB) {
    this.nodeT = nodeT;
    this.nodeB = nodeB;
    this.weight = 2 + nodeB.relSize * 1;
  }

  color = () => this.nodeB.color;

  startAnimation = (offset = 0) => {
    if (this.animationStart == Number.MAX_VALUE)
      this.animationStart = globalTime + offset;
  };

  render = () => {
    if (globalTime - this.animationStart < 0) return;

    if (!this.isStatic) {
      this.animationProgress = animEase(
        (globalTime - this.animationStart) / 1000,
      );
      if (this.animationProgress >= 1) {
        this.isStatic = true;
        this.animX = this.nodeB.xT;
        this.animY = this.nodeB.yT;
      } else {
        this.animX = bezierPoint(
          this.nodeT.xB,
          this.nodeT.xB,
          this.nodeB.xT,
          this.nodeB.xT,
          this.animationProgress,
        );

        this.animY = bezierPoint(
          this.nodeT.yB,
          (this.nodeT.yB + this.nodeB.yT) / 2,
          (this.nodeT.yB + this.nodeB.yT) / 2,
          this.nodeB.yT,
          this.animationProgress,
        );
      }
    }
    if (this.animationProgress >= 0.97) {
      this.nodeB.startAnimation();
    }

    strokeWeight(this.weight);
    noFill();
    stroke(
      lerpColor(color(bgCol), color(accentCol), this.nodeB.relSize * 1 + 0.7),
    );
    bezier(
      this.nodeT.xB,
      this.nodeT.yB,
      this.nodeT.xB,
      (this.nodeT.yB + this.nodeB.yT) / 2,
      this.animX,
      (this.nodeT.yB + this.nodeB.yT) / 2,
      this.animX,
      this.animY,
    );
  };
}

draw = () => {
  cursor(ARROW);
  frameRate(120);
  if (!firstFrameTime && frameCount <= 1) {
    firstFrameTime = millis();
  }
  // ---- update global animation state ----
  const initialSpeedScalingEaseIO =
    (cos(min((millis() - firstFrameTime) / 8000, 1.0) * PI) + 1) / 2;
  const initialSpeedScalingEase =
    (cos(min((millis() - firstFrameTime) / 8000, 1.0) ** (1 / 2) * PI) + 1) / 2;
  const initAnimationSpeedFactor = 1.0 - 0.4 * initialSpeedScalingEaseIO;
  // update global scaling-aware clock
  globalTime += globalAnimSpeed * initAnimationSpeedFactor * deltaTime;

  if (nodes.length == 0) {
    const spacingHeight = height * 1.3;
    const spacingWidth = width * 1.3;
    treeStructData.layout.forEach((lay, index) => {
      new Node(
        spacingWidth * lay[0] - spacingWidth / 2,
        20 + spacingHeight * lay[1] - spacingHeight / 2,
        1 - treeStructData.metrics[index],
        index,
      );
    });
    treeStructData.edges.forEach((ind) => {
      nodes[ind[0]].child(nodes[ind[1]]);
    });
    nodes.forEach((n) => {
      if (n.isRootNode) n.startAnimation();
    });
    nodes[0].selected = true;
    setCodeAndPlan(
      treeStructData.code[0],
      treeStructData.plan[0],
    )
  }

  const staticNodes = nodes.filter(
    (n) => n.isStatic || n.animationProgress >= 0.7,
  );
  if (staticNodes.length > 0) {
    const largestNode = staticNodes.reduce((prev, current) =>
      prev.relSize > current.relSize ? prev : current,
    );
    if (!manualSelection) {
      if (!largestNode.selected) {
        setCodeAndPlan(
          treeStructData.code[largestNode.treeInd],
          treeStructData.plan[largestNode.treeInd],
        );
      }
      staticNodes.forEach((node) => {
        node.selected = node === largestNode;
      });
    }
  }
  background(bgCol);
  // global animation transforms
  translate(width / 2, height / 2);
  scale(scaleFactor);

  
  // ---- fg render ----
  edges.forEach((e) => e.render());
  nodes.forEach((n) => n.render());
  
};

    </script>
    <title>AIDE Run Visualization</title>
    <style>
      body,
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        overflow: scroll;
      }
      body {
        background-color: #f2f0e7;
      }
      canvas {
        float: left;
        height: 100vh;
        width: 40vw;
      }
      #text-container {
        float: right;
        height: 100vh;
        width: 50vw;
        background-color: #282c34;
      }
      #plan {
        /* border-left: 2px solid #282c34; */
        background-color: #282c34;
        color: #f2f0e7;
        min-height: 5rem;
        padding: 1em 0 1em 1em;
      }
    </style>
  </head>
  <body>
    <pre
      id="text-container"
    ><div id="plan"></div><hr><code id="code" class="language-python"></code></pre>
  </body>
</html>
